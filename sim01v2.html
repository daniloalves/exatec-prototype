<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exatec ‚Äì Simulador da Segunda Lei de Newton</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e9f0 100%);
            color: #2c3e50;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            padding: 20px 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 28px;
            font-weight: 600;
        }

        .header p {
            color: #34495e;
            font-size: 14px;
            margin-top: 5px;
        }

        .main-container {
            display: grid;
            grid-template-columns: 0.2fr 0.8fr 0.5fr;
            grid-template-rows: auto auto;
            gap: 20px;
            padding: 20px;
            /* min-height: calc(100vh - 100px); */
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            /* grid-row: 1 / 3; */
            /* max-height: 97%; */
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: #34495e;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: none;
        }

        .value-display {
            font-size: 16px;
            font-weight: 600;
            color: #ff8c00;
            margin-top: 5px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 30px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #2c3e50;
        }

        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }

        .btn-reset {
            background: #e74c3c;
            color: white;
        }

        .btn-reset:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .theory-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            max-height: 500px;
            overflow-y: auto;
        }

        .theory-panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 10px;
        }

        .theory-panel p {
            font-size: 13px;
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }

        .formula-box {
            background: #f8f9fa;
            border-left: 4px solid #ffd700;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
        }

        .formula-box h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .formula {
            font-size: 24px;
            font-weight: bold;
            color: #ff8c00;
            text-align: center;
            margin: 10px 0;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 14px;
        }

        .input-group label {
            flex: 1;
            font-weight: 500;
        }

        .input-group input {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
        }

        .calculation-box {
            background: #fff8e1;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
        }

        .calculation-box p {
            margin: 5px 0;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .calculation-box .result {
            color: #ff8c00;
            font-size: 16px;
        }

        .canvas-area {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #simulationCanvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 100%);
        }

        .bottom-area {
            grid-column: 1 / 4;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .metric-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            text-align: center;
        }

        .metric-card h3 {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric-card .value {
            font-size: 32px;
            font-weight: bold;
            color: #ff8c00;
        }

        .metric-card .unit {
            font-size: 16px;
            color: #7f8c8d;
            margin-left: 5px;
        }

        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
        }

        .chart-card h3 {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .challenge-card {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            color: #2c3e50;
        }

        .challenge-card h3 {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .challenge-card p {
            font-size: 14px;
            margin-bottom: 10px;
        }

        .challenge-progress {
            background: rgba(255,255,255,0.3);
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .challenge-progress-bar {
            height: 100%;
            background: white;
            transition: width 0.3s;
            border-radius: 10px;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Exatec ‚Äì Simulador da Segunda Lei de Newton</h1>
        <p>Plataforma Educacional de F√≠sica para Escolas</p>
    </div>

    <div class="main-container">
        <!-- Painel de Controles -->
        <div class="sidebar">
            <h2>‚öôÔ∏è Controles</h2>
            
            <div class="control-group">
                <label>Massa (kg)</label>
                <input type="range" id="massSlider" min="10" max="200" value="50" step="5">
                <div class="value-display" id="massValue">50 kg</div>
            </div>

            <div class="control-group">
                <label>For√ßa Aplicada (N)</label>
                <input type="range" id="forceSlider" min="0" max="500" value="200" step="10">
                <div class="value-display" id="forceValue">200 N</div>
            </div>

            <div class="control-group">
                <label>Coeficiente de Atrito (Œº)</label>
                <input type="range" id="frictionSlider" min="0" max="1" value="0.2" step="0.05">
                <div class="value-display" id="frictionValue">0.20</div>
            </div>

            <div class="btn-group">
                <button class="btn-start" id="startBtn">‚ñ∂ Iniciar</button>
                <button class="btn-reset" id="resetBtn">‚Üª Resetar</button>
            </div>
        </div>

        <!-- √Årea da Simula√ß√£o -->
        <div class="canvas-area">
            <canvas id="simulationCanvas" width="700" height="400"></canvas>
        </div>

        <!-- Painel Te√≥rico -->
        <div class="theory-panel">
            <h2>üìò Fundamento Te√≥rico</h2>
            <p>
                A <strong>Segunda Lei de Newton</strong> estabelece que a acelera√ß√£o de um corpo √© diretamente proporcional √† for√ßa resultante que atua sobre ele e inversamente proporcional √† sua massa.
            </p>

            <div class="formula-box">
                <h3>F√≥rmula Fundamental</h3>
                <div class="formula">F = m ¬∑ a</div>
                <p style="text-align: center; font-size: 12px; color: #7f8c8d;">
                    Onde:<br>
                    F = For√ßa (N)<br>
                    m = massa (kg)<br>
                    a = acelera√ß√£o (m/s¬≤)
                </p>
            </div>

            <div class="formula-box">
                <h3>Par√¢metros Atuais</h3>
                
                <div class="input-group">
                    <label>Massa (m):</label>
                    <input type="number" id="massInput" value="50" min="10" max="200" step="5">
                    <span>kg</span>
                </div>

                <div class="input-group">
                    <label>For√ßa Aplicada (F):</label>
                    <input type="number" id="forceInput" value="200" min="0" max="500" step="10">
                    <span>N</span>
                </div>

                <div class="input-group">
                    <label>Atrito (Œº):</label>
                    <input type="number" id="frictionInput" value="0.2" min="0" max="1" step="0.05">
                </div>

                <div class="calculation-box">
                    <p>For√ßa de Atrito: <span class="result" id="frictionForceCalc">98 N</span></p>
                    <p>For√ßa Resultante: <span class="result" id="resultantForceCalc">102 N</span></p>
                    <p>Acelera√ß√£o: <span class="result" id="accelerationCalc">2.04 m/s¬≤</span></p>
                </div>
            </div>
        </div>

        <!-- √Årea de M√©tricas -->
        <div class="bottom-area">
            <div class="metric-card">
                <h3>Acelera√ß√£o</h3>
                <div>
                    <span class="value" id="accelMetric">0.00</span>
                    <span class="unit">m/s¬≤</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Velocidade</h3>
                <div>
                    <span class="value" id="velocityMetric">0.00</span>
                    <span class="unit">m/s</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>For√ßa Resultante</h3>
                <div>
                    <span class="value" id="forceMetric">0.00</span>
                    <span class="unit">N</span>
                </div>
            </div>

            <div class="chart-card">
                <h3>Veloc√≠metro</h3>
                <canvas id="speedometerCanvas" width="200" height="150"></canvas>
            </div>

            <div class="chart-card">
                <h3>Velocidade √ó Tempo</h3>
                <canvas id="chartCanvas" width="350" height="150"></canvas>
            </div>

            <div class="challenge-card">
                <h3>üéØ Desafio</h3>
                <p>Alcance 10 m/s com seu ve√≠culo!</p>
                <div class="challenge-progress">
                    <div class="challenge-progress-bar" id="challengeProgress"></div>
                </div>
                <p style="margin-top: 10px; font-weight: 600;" id="challengeStatus">Progresso: 0%</p>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONSTANTES ====================
        const g = 9.8; // Acelera√ß√£o da gravidade (m/s¬≤)
        
        // ==================== ESTADO DA SIMULA√á√ÉO ====================
        let state = {
            mass: 50,           // kg
            appliedForce: 200,  // N
            friction: 0.2,      // Œº
            velocity: 0,        // m/s
            position: 50,       // pixels
            acceleration: 0,    // m/s¬≤
            isRunning: false,
            time: 0,
            wheelRotation: 0
        };

        // Dados para o gr√°fico de velocidade
        let velocityData = [];
        let timeData = [];
        const maxDataPoints = 50;

        // ==================== ELEMENTOS DOM ====================
        const massSlider = document.getElementById('massSlider');
        const forceSlider = document.getElementById('forceSlider');
        const frictionSlider = document.getElementById('frictionSlider');
        const massValue = document.getElementById('massValue');
        const forceValue = document.getElementById('forceValue');
        const frictionValue = document.getElementById('frictionValue');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');

        const massInput = document.getElementById('massInput');
        const forceInput = document.getElementById('forceInput');
        const frictionInput = document.getElementById('frictionInput');

        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const speedometerCanvas = document.getElementById('speedometerCanvas');
        const speedometerCtx = speedometerCanvas.getContext('2d');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');

        // ==================== FUN√á√ïES DE F√çSICA ====================
        function calculatePhysics() {
            // For√ßa de atrito = Œº ¬∑ m ¬∑ g
            const frictionForce = state.friction * state.mass * g;
            
            // For√ßa resultante = For√ßa aplicada - For√ßa de atrito
            const resultantForce = Math.max(state.appliedForce - frictionForce, 0);
            
            // Acelera√ß√£o = For√ßa resultante / Massa
            state.acceleration = resultantForce / state.mass;
            
            return {
                frictionForce: frictionForce,
                resultantForce: resultantForce,
                acceleration: state.acceleration
            };
        }

        function updateCalculations() {
            const calc = calculatePhysics();
            
            document.getElementById('frictionForceCalc').textContent = calc.frictionForce.toFixed(2) + ' N';
            document.getElementById('resultantForceCalc').textContent = calc.resultantForce.toFixed(2) + ' N';
            document.getElementById('accelerationCalc').textContent = calc.acceleration.toFixed(2) + ' m/s¬≤';
            
            document.getElementById('accelMetric').textContent = calc.acceleration.toFixed(2);
            document.getElementById('velocityMetric').textContent = state.velocity.toFixed(2);
            document.getElementById('forceMetric').textContent = calc.resultantForce.toFixed(2);
        }

        // ==================== SINCRONIZA√á√ÉO DE CONTROLES ====================
        massSlider.addEventListener('input', (e) => {
            state.mass = parseFloat(e.target.value);
            massValue.textContent = state.mass + ' kg';
            massInput.value = state.mass;
            updateCalculations();
        });

        forceSlider.addEventListener('input', (e) => {
            state.appliedForce = parseFloat(e.target.value);
            forceValue.textContent = state.appliedForce + ' N';
            forceInput.value = state.appliedForce;
            updateCalculations();
        });

        frictionSlider.addEventListener('input', (e) => {
            state.friction = parseFloat(e.target.value);
            frictionValue.textContent = state.friction.toFixed(2);
            frictionInput.value = state.friction;
            updateCalculations();
        });

        massInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (!isNaN(val) && val >= 10 && val <= 200) {
                state.mass = val;
                massSlider.value = val;
                massValue.textContent = val + ' kg';
                updateCalculations();
            }
        });

        forceInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (!isNaN(val) && val >= 0 && val <= 500) {
                state.appliedForce = val;
                forceSlider.value = val;
                forceValue.textContent = val + ' N';
                updateCalculations();
            }
        });

        frictionInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (!isNaN(val) && val >= 0 && val <= 1) {
                state.friction = val;
                frictionSlider.value = val;
                frictionValue.textContent = val.toFixed(2);
                updateCalculations();
            }
        });

        // ==================== CONTROLES DE SIMULA√á√ÉO ====================
        startBtn.addEventListener('click', () => {
            state.isRunning = !state.isRunning;
            startBtn.textContent = state.isRunning ? '‚è∏ Pausar' : '‚ñ∂ Iniciar';
        });

        resetBtn.addEventListener('click', () => {
            state.velocity = 0;
            state.position = 50;
            state.time = 0;
            state.isRunning = false;
            state.wheelRotation = 0;
            startBtn.textContent = '‚ñ∂ Iniciar';
            velocityData = [];
            timeData = [];
            updateCalculations();
            updateChallenge();
        });

        // ==================== DESENHO DO CARRO ====================
        function drawCar(x, y) {
            const carWidth = 80;
            const carHeight = 40;
            
            // Sombra
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(x + carWidth/2, y + carHeight + 5, carWidth/2, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Corpo do carro
            ctx.fillStyle = '#ff8c00';
            ctx.fillRect(x, y, carWidth, carHeight);
            
            // Cabine
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(x + 15, y - 20, 40, 20);
            
            // Janelas
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(x + 18, y - 17, 15, 14);
            ctx.fillRect(x + 37, y - 17, 15, 14);
            
            // Rodas
            const wheel1X = x + 15;
            const wheel2X = x + 55;
            const wheelY = y + carHeight;
            const wheelRadius = 8;
            
            // Roda 1
            ctx.save();
            ctx.translate(wheel1X, wheelY);
            ctx.rotate(state.wheelRotation);
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(0, 0, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(-2, -wheelRadius, 4, wheelRadius * 2);
            ctx.fillRect(-wheelRadius, -2, wheelRadius * 2, 4);
            ctx.restore();
            
            // Roda 2
            ctx.save();
            ctx.translate(wheel2X, wheelY);
            ctx.rotate(state.wheelRotation);
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(0, 0, wheelRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(-2, -wheelRadius, 4, wheelRadius * 2);
            ctx.fillRect(-wheelRadius, -2, wheelRadius * 2, 4);
            ctx.restore();
        }

        // ==================== DESENHO DA CENA ====================
        function drawScene() {
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fundo (c√©u)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87ceeb');
            gradient.addColorStop(1, '#e0f6ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ch√£o
            const groundY = canvas.height - 80;
            ctx.fillStyle = '#8b7355';
            ctx.fillRect(0, groundY, canvas.width, 80);
            
            // Linha do ch√£o
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
            
            // Marcas de dist√¢ncia
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, groundY);
                ctx.lineTo(i, groundY + 10);
                ctx.stroke();
            }
            
            // Carro
            const carY = groundY - 48;
            drawCar(state.position, carY);
            
            // Vetor de for√ßa
            if (state.appliedForce > 0) {
                const forceScale = state.appliedForce / 5;
                const arrowX = state.position + 80;
                const arrowY = carY + 20;
                
                ctx.strokeStyle = '#e74c3c';
                ctx.fillStyle = '#e74c3c';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX + forceScale, arrowY);
                ctx.stroke();
                
                // Ponta da seta
                ctx.beginPath();
                ctx.moveTo(arrowX + forceScale, arrowY);
                ctx.lineTo(arrowX + forceScale - 10, arrowY - 5);
                ctx.lineTo(arrowX + forceScale - 10, arrowY + 5);
                ctx.closePath();
                ctx.fill();
                
                // Texto
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('F = ' + state.appliedForce + ' N', arrowX + 10, arrowY - 10);
            }
            
            // Informa√ß√µes na tela
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Tempo: ' + state.time.toFixed(1) + ' s', 10, 25);
            ctx.fillText('Velocidade: ' + state.velocity.toFixed(2) + ' m/s', 10, 45);
            ctx.fillText('Posi√ß√£o: ' + ((state.position - 50) / 10).toFixed(1) + ' m', 10, 65);
        }

        // ==================== VELOC√çMETRO ====================
        function drawSpeedometer() {
            const centerX = speedometerCanvas.width / 2;
            const centerY = speedometerCanvas.height - 20;
            const radius = 70;
            
            speedometerCtx.clearRect(0, 0, speedometerCanvas.width, speedometerCanvas.height);
            
            // Arco de fundo
            speedometerCtx.strokeStyle = '#e0e0e0';
            speedometerCtx.lineWidth = 15;
            speedometerCtx.beginPath();
            speedometerCtx.arc(centerX, centerY, radius, Math.PI, 2 * Math.PI);
            speedometerCtx.stroke();
            
            // Arco colorido
            const maxSpeed = 20; // m/s
            const angle = Math.PI + (Math.min(state.velocity, maxSpeed) / maxSpeed) * Math.PI;
            
            const gradient = speedometerCtx.createLinearGradient(0, 0, speedometerCanvas.width, 0);
            gradient.addColorStop(0, '#ffd700');
            gradient.addColorStop(1, '#ff8c00');
            
            speedometerCtx.strokeStyle = gradient;
            speedometerCtx.lineWidth = 15;
            speedometerCtx.beginPath();
            speedometerCtx.arc(centerX, centerY, radius, Math.PI, angle);
            speedometerCtx.stroke();
            
            // Ponteiro
            const needleAngle = Math.PI + (Math.min(state.velocity, maxSpeed) / maxSpeed) * Math.PI;
            const needleLength = radius - 10;
            
            speedometerCtx.strokeStyle = '#2c3e50';
            speedometerCtx.lineWidth = 3;
            speedometerCtx.beginPath();
            speedometerCtx.moveTo(centerX, centerY);
            speedometerCtx.lineTo(
                centerX + Math.cos(needleAngle) * needleLength,
                centerY + Math.sin(needleAngle) * needleLength
            );
            speedometerCtx.stroke();
            
            // Centro
            speedometerCtx.fillStyle = '#2c3e50';
            speedometerCtx.beginPath();
            speedometerCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            speedometerCtx.fill();
            
            // Texto
            speedometerCtx.fillStyle = '#2c3e50';
            speedometerCtx.font = 'bold 20px Arial';
            speedometerCtx.textAlign = 'center';
            speedometerCtx.fillText(state.velocity.toFixed(1), centerX, centerY - 30);
            speedometerCtx.font = '12px Arial';
            speedometerCtx.fillText('m/s', centerX, centerY - 10);
        }

        // ==================== GR√ÅFICO DE VELOCIDADE ====================
        function drawChart() {
            const padding = 40;
            const chartWidth = chartCanvas.width - 2 * padding;
            const chartHeight = chartCanvas.height - 2 * padding;
            
            chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
            
            // Eixos
            chartCtx.strokeStyle = '#2c3e50';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding);
            chartCtx.lineTo(padding, padding + chartHeight);
            chartCtx.lineTo(padding + chartWidth, padding + chartHeight);
            chartCtx.stroke();
            
            // Labels
            chartCtx.fillStyle = '#2c3e50';
            chartCtx.font = '10px Arial';
            chartCtx.textAlign = 'center';
            chartCtx.fillText('Tempo (s)', chartCanvas.width / 2, chartCanvas.height - 5);
            chartCtx.save();
            chartCtx.translate(10, chartCanvas.height / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.fillText('Velocidade (m/s)', 0, 0);
            chartCtx.restore();
            
            // Desenhar dados
            if (velocityData.length > 1) {
                const maxVelocity = Math.max(...velocityData, 10);
                
                chartCtx.strokeStyle = '#ff8c00';
                chartCtx.lineWidth = 2;
                chartCtx.beginPath();
                
                for (let i = 0; i < velocityData.length; i++) {
                    const x = padding + (i / (maxDataPoints - 1)) * chartWidth;
                    const y = padding + chartHeight - (velocityData[i] / maxVelocity) * chartHeight;
                    
                    if (i === 0) {
                        chartCtx.moveTo(x, y);
                    } else {
                        chartCtx.lineTo(x, y);
                    }
                }
                
                chartCtx.stroke();
            }
        }

        // ==================== DESAFIO ====================
        function updateChallenge() {
            const target = 10; // m/s
            const progress = Math.min((state.velocity / target) * 100, 100);
            
            document.getElementById('challengeProgress').style.width = progress + '%';
            document.getElementById('challengeStatus').textContent = 'Progresso: ' + progress.toFixed(0) + '%';
            
            if (progress >= 100) {
                document.getElementById('challengeStatus').textContent = '‚úÖ Desafio Conclu√≠do!';
            }
        }

        // ==================== LOOP DE ANIMA√á√ÉO ====================
        let lastTime = Date.now();
        
        function animate() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000; // segundos
            lastTime = currentTime;
            
            if (state.isRunning) {
                // Atualizar f√≠sica
                calculatePhysics();
                
                // Atualizar velocidade: v = v0 + a¬∑t
                state.velocity += state.acceleration * deltaTime;
                
                // Atualizar posi√ß√£o (convers√£o: 1 m = 10 pixels)
                state.position += state.velocity * deltaTime * 10;
                
                // Atualizar rota√ß√£o das rodas
                state.wheelRotation += state.velocity * deltaTime * 0.5;
                
                // Resetar posi√ß√£o se sair da tela
                if (state.position > canvas.width) {
                    state.position = -80;
                }
                
                // Atualizar tempo
                state.time += deltaTime;
                
                // Armazenar dados para o gr√°fico
                velocityData.push(state.velocity);
                timeData.push(state.time);
                
                if (velocityData.length > maxDataPoints) {
                    velocityData.shift();
                    timeData.shift();
                }
                
                updateCalculations();
                updateChallenge();
            }
            
            drawScene();
            drawSpeedometer();
            drawChart();
            
            requestAnimationFrame(animate);
        }

        // ==================== INICIALIZA√á√ÉO ====================
        updateCalculations();
        animate();
    </script>
</body>
</html>
